#!/usr/bin/env python3
"""
Generate templates.yaml manifest from directory structure.

Scans all template directories, parses versions using semver,
extracts metadata from YAML files, and generates the manifest.

Run automatically via GitHub Actions on merge to master.
"""

import os
import re
from datetime import datetime, timezone
from pathlib import Path

import yaml

# Use packaging for proper semver sorting (handles pre-release versions)
try:
    from packaging.version import parse as parse_version
except ImportError:
    # Fallback for environments without packaging
    from distutils.version import LooseVersion as parse_version

REPO_ROOT = Path(__file__).parent.parent
MANIFEST_FILE = REPO_ROOT / "templates.yaml"

# Directories to skip (not templates)
SKIP_DIRS = {"scripts", ".git", ".github", "__pycache__"}


def find_template_versions(template_dir: Path) -> list[dict]:
    """Find all versions for a template directory."""
    versions = []

    for version_dir in template_dir.iterdir():
        if not version_dir.is_dir():
            continue

        # Look for the YAML file
        yaml_file = version_dir / f"{template_dir.name}.yaml"
        if not yaml_file.exists():
            # Try to find any yaml file
            yaml_files = list(version_dir.glob("*.yaml"))
            if yaml_files:
                yaml_file = yaml_files[0]
            else:
                continue

        # Read YAML to get metadata
        with open(yaml_file) as f:
            try:
                data = yaml.safe_load(f)
            except yaml.YAMLError:
                continue

        versions.append({
            "version": version_dir.name,
            "extends": data.get("extends"),
            "usable_alone": data.get("usable_alone", True),
            "layer": data.get("layer"),
            "description": data.get("description", ""),
        })

    return versions


def sort_versions(versions: list[str]) -> list[str]:
    """Sort versions using semver (newest first)."""
    return sorted(versions, key=parse_version, reverse=True)


def get_latest_stable_version(versions: list[str]) -> str:
    """Get the latest stable version (excludes -dev, -alpha, -beta, -rc)."""
    stable_pattern = re.compile(r"^[0-9]+\.[0-9]+\.[0-9]+$")
    stable_versions = [v for v in versions if stable_pattern.match(v)]

    if stable_versions:
        return sort_versions(stable_versions)[0]

    # If no stable versions, return the latest overall
    return sort_versions(versions)[0] if versions else None


def generate_manifest() -> dict:
    """Generate the manifest from directory structure."""
    templates = {}

    for template_dir in REPO_ROOT.iterdir():
        if not template_dir.is_dir():
            continue
        if template_dir.name in SKIP_DIRS or template_dir.name.startswith("."):
            continue

        versions_data = find_template_versions(template_dir)
        if not versions_data:
            continue

        version_strings = [v["version"] for v in versions_data]
        latest = get_latest_stable_version(version_strings)

        # Get metadata from latest version
        latest_data = next((v for v in versions_data if v["version"] == latest), versions_data[0])

        templates[template_dir.name] = {
            "latest": latest,
            "versions": sort_versions(version_strings),
            "extends": latest_data["extends"],
            "usable_alone": latest_data["usable_alone"],
            "layer": latest_data["layer"],
            "description": latest_data["description"],
        }

    # Sort templates alphabetically
    templates = dict(sorted(templates.items()))

    return {
        "schema_version": "1.0",
        "generated_at": datetime.now(timezone.utc).isoformat(),
        "templates": templates,
    }


def write_manifest(manifest: dict):
    """Write manifest to YAML file with nice formatting."""

    # Custom representer for cleaner output
    def str_representer(dumper, data):
        if "\n" in data:
            return dumper.represent_scalar("tag:yaml.org,2002:str", data, style="|")
        return dumper.represent_scalar("tag:yaml.org,2002:str", data)

    yaml.add_representer(str, str_representer)

    header = "# Auto-generated manifest - do not edit manually\n"
    header += "# Generated by: scripts/generate_manifest.py\n"
    header += "# To update: merge PR to master branch\n\n"

    with open(MANIFEST_FILE, "w") as f:
        f.write(header)
        yaml.dump(manifest, f, default_flow_style=False, sort_keys=False, allow_unicode=True)

    print(f"Generated manifest: {MANIFEST_FILE}")


def main():
    print("Generating templates.yaml manifest...")
    print(f"Scanning: {REPO_ROOT}")

    manifest = generate_manifest()

    print(f"\nFound {len(manifest['templates'])} templates:")
    for name, data in manifest["templates"].items():
        versions_str = ", ".join(data["versions"])
        print(f"  - {name}: latest={data['latest']} versions=[{versions_str}]")

    write_manifest(manifest)
    print("\nDone!")


if __name__ == "__main__":
    main()
